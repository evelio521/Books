ITEM29:编译防火墙
	//在C++中，如果定义中的任何部分被改变了，那么这个类所有的使用者
	//的代码必须重新编译。为了降低这种依赖性，使用的一种常见技术就是
	//利用一个不透明的指针来隐藏一部分实现细节
	class X 
	{
	public:
	  /* ... public members ... */
	protected:
	  /* ... protected members? ... */
	private:
	  /* ... private members? ... */
	  struct XImpl;
	  XImpl* pimpl_;         // opaque pointer to
	                         // forward-declared class
	};
	
	//1.哪些部分应该放入Ximpl? 有常见的四种原则，他们是
	     1) 将全部的私有成员(不包括函数)放入Ximpl
	      //这是个不错的开端，因为现在我们得以对任何只用作数据成员的类进行前置声明
	      //(而不是使用#include语句包含类真正声明--这会使客户端代码形成依赖性)。
	     2) 将全部的私有成员(包括函数)放入Ximpl 
	      //C++中客户端成员不应该关心这些部分就意味着私有，而私有的东西最好藏起来
	      //警告:
	       //1.即使虚函数是私有的，也不能将虚拟成员函数隐藏在pimpl类中。
	       //  如果虚函数复写基类中的同名函数，那么虚函数就应出现在真正的派生类中
	       //  如果虚函数不是继承而来，为了让后来的类能给复写他，也应该出现在可见类中
	       //2.如果pimpl中的函数需要使用其他函数，其可能需要一个指向可见对象的反向指针--这增加
	       //  了一层间接性。这个反向指针通常约定成self_
	     3) 将全部的私有成员和保护成员放入Xipml
	       //这种做法是错误的，保护成员绝对不能放入pimpl中
	     4) 使用Ximpl完全成为原来的X，将X编写为一个完全由简单的前置函数组成的公共接口
	       //只有在有限的情况下用，好处是可以避免使用反向指针，坏处是使得可见类对于继承完成无用，无论是基类还是派生类
	       
   //2.Ximpl需要一个指向X对象的反向指针。