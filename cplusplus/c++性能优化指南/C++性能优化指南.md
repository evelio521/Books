##c++性能优化指南

### Chapter 2

> 某些内存地址可能是设备寄存器，而不是普通内存。这些地址的值可能会在同一个线程对该地址的两次连续读的间隔发生变化，这表示硬件发生了变化。在 C++中用 volatile 关键字定义这些地址。声明一个volatile 变量会要求编译器在每次使用该变 量时都获取它的一份新的副本，而不用通过将该变量的值保存在一个寄存器中并复用它 来优化程序。另外，也可以声明指向 volatile 内存的指针。

> C++11 提供了一个名为 std::atomic<> 的特性，可以让内存在一段短暂的时间内表现得仿佛是字节的简单线性存储一样，这样可以远离所有现代处理器的复杂性，包括多线程执行、多层高速缓存等。有些开发人员误以为这与 volatile 是一样的，其实他们错了。

> 计算机的主内存相对于它内部的逻辑门和寄存器来说非常慢。将电子从微处理器芯片中注入相对广阔的一块铜制电路板上的电路，然后将其沿着电路推到几厘米外的内存芯片中，这个过程所花费的时间为电子穿越微处理器内各个独立的微距晶体管所需时间的数千倍。主内存太慢，所以桌面级处理器在从主内存中读取一个数据字的时间内，可以执行数百条指令。

> 虽然 C++ 认为每个字节都是可以独立访问的，但计算机会通过获取更大块的数据来补偿缓慢的内存速度。最小型的处理器可以每次从主内存中获取 1 字节，桌面级处理器则可以立即获取 64 字节。一些超级计算机和图形处理器还可以获取更多。

>当 C++ 获取一个多字节类型的数据，比如一个 int、double 或者指针时，构成数据的字节可能跨越了两个物理内存字。这种访问被称为非对齐的内存访问(unaligned memory access)。此处优化的意义在于，一次非对齐的内存访问的时间相当于这些字节在同一个字 中时的两倍，因为需要读取两个字。C++编译器会帮助我们对齐结构体，使每个字段的起 始字节地址都是该字段的大小的倍数。但是这样也会带来相应的问题:结构体的“洞”中 包含了无用的数据。在定义结构体时，对各个数据字段的大小和顺序稍加注意，可以在保持对齐的前提下使结构体更加紧凑。

> 在桌面级处理器中，通过一级高速缓存、二级高速缓存、三级高速缓存、主内存和磁盘上的虚拟内存页访问内存的时间开销范围可以跨越五个数量级。高速缓存层次中每一层的速度大约是它下面一层的 10 倍 。

> 当执行单元需要获取不在高速缓存中的数据时，有一些当前处于高速缓存中的数据必须被舍弃以换取足够的空余空间。通常，选择放弃的数据都是最近很少被使用的数据。这一点与性能优化有着紧密的关系，因为这意味着访问那些被频繁地访问过的存储位置的速度会比访问不那么频繁地被访问的存储位置更快。

> 读取一个不在高速缓存中的字节甚至会导致许多临近的字节也都被缓存起来(这也意味 着，许多当前被缓存的字节将会被舍弃)。这些临近的字节也就可以被高速访问了。对于性能优化而言，这一点非常重要，因为这意味着平均而言，访问内存中相邻位置的字节要比访问互相远隔的字节的速度更快。

> 字节序(endian-ness)只是 C++ 不能指定 int中位的存储方式或是设置联合体中的一个字 段会如何影响其他字段的原因之一。所编写的程序可以工作于一类计算机上，却在另一类 计算机上崩溃，原因也在于字节序。

```c++
int checkCPUendian()
{  //返回1，为小端；反之，为大端；
    union
    {
        unsigned int  a;
        unsigned char b;
    }c;
    c.a = 1;
    return 1 == c.b;
}
```

> 从磁盘上获取一个内存块需要花费数十毫秒，对现代计算机来说，这几乎是一个 恒定值。

> 高速缓存和虚拟内存带来的一个影响是，由于高速缓存的存在，在进行性能测试时，一个 函数运行于整个程序的上下文中时的执行速度可能是运行于测试套件中时的万分之一。当 运行于整个程序的上下文中时，函数和它的数据不太可能存储至缓存中，而在测试套件的 上下文中，它们则通常会被缓存起来。这个影响放大了减少内存或磁盘使用量带来的优化收益，而减小代码体积的优化收益则没有任何变化。 
>
> 第二个影响则是，如果一个大程序访问许多离散的内存地址，那么可能没有足够的高速缓存来保存程序刚刚使用的数据。这会导致一种性能衰退，称为页抖动(page thrashing)。当在微处理器内部的高速缓存中发生页抖动时，性能会降低;当在操作系统的虚拟缓存文件中发生页抖动时，性能会下降为原来的 1/1000。过去，计算机的物理内存很少，页抖动更加普遍。不过，如今这个问题仍然会发生。

> 切换上下文究竟是什么意思呢?如果操作系统正在将一个线程切换至同一个程序的另外一个线程，这表示要为即将暂停的线程保存处理器中的寄存器，然后为即将被继续执行的线 程加载之前保存过的寄存器。现代处理器中的寄存器包含数百字节的数据。当新线程继续 执行时，它的数据可能并不在高速缓存中，所以当加载新的上下文到高速缓存中时，会有 一个缓慢的初始化阶段。因此，切换线程上下文的成本很高。

> 当操作系统从一个程序切换至另外一个程序时，这个过程的开销会更加昂贵。所有脏的高 速缓存页面(页面被入了数据，但还没有反映到主内存中)都必须被刷新至物理内存中。 所有的处理器寄存器都需要被保存。然后，内存管理器中的“物理地址到虚拟地址”的内 存页寄存器也需要被保存。接着，新线程的“物理地址到虚拟地址”的内存页寄存器和处 理器寄存器被载入。最后就可以继续执行了。但是这时高速缓存是空的，因此在高速缓存被填充满之前，还有一段缓慢且需要激烈地竞争内存的初始化阶段。 

> 在底层，编译器能够而且有时也确实会对语句进行重新排序以改善性能。但是编译器知道在测试一个变量或是将其赋值给另外一个变量之前，必须先确定它包含了所有的最新计算结果。现代处理器也可能会选择乱序执行指令，不过它们包含了可以确保在随后读 取同一个内存地址之前，一定会先向该地址写入值的逻辑。甚至微处理器的内存控制逻辑 可能会选择延迟写入内存以优化内存总线的使用 。

### Chapter 3

> 如果只能让程序的运行速度提高 1% 是不值得冒险去修改代码的，因为修改代码可能会引入 bug。只有能显著地提升性能时才值得修改代码。而且，这 1% 的速度提升可能只是将测量套件的误差当作了性能改善。因此，我们必须用随机抽样统计和置信水平来证明速度的提升。但是完全没有必要为了这么一点点性能提升花费这么大气力。当性能提升 20%的时候，事情就完全不同了。它会消除所有反对方法论的声音 。

> 性能优化的基本规则是 90/10 规则:一个程序花费 90% 的时间执行其中 10% 的代码。这 只是一条启发性的规则，并非自然法则，但对于我们的思考和计划却具有指导性。这条规 则有时也被称为 80/20 规则，但思想是一样的。直观地说，90/10 规则表示某些代码块是会被频繁地执行的热点(hot spot)，而其他代码则几乎不会被执行。这些热点就是我们要进 行性能优化的对象。

> 性能测试目标包括启动时间 、退出时间 、响应时间和吞吐量等。

> 热点函数可以使用StopWatch类来测试性能。

> 有一条有效的规则能够帮助我们评估一条 C++ 语句的开销有多大，那就是计算该语句对 内存的读写次数。例如，有一条语句 a = b + c;，其中 a、b 和 c 都是整数，b 和 c 的值 必须从内存中读取，而且它们的和必须写入至内存中的位置 a。因此，这条语句的开销是 三次内存访问。这个次数不依赖于微处理器的指令集。这是语句不可避免的、必然会发生 的开销。 
>
> 再比如，r = *p + a[i];这条语句访问内存的次数如下:一次访问用于读取i，一次读取 a[i]，一次读取 p，一次读取 *p 所指向的数据，一次将结果写入至 r。也就是说 , 总共进 行了 5 次访问

### Chapter 4

> 为了能让字符串增长时重新分配内存的开销“分期付款”，std::string 使用了一个小技 巧。字符串向内存管理器申请的字符缓冲区的大小并非与字符串所需存储的字符数完全一 致，而是比该数值更大。例如，有些字符串的实现方式所申请的字符缓冲区的大小是需要 存储的字符数的两倍。这样，在下一次申请新的字符缓冲区之前，字符串的容量足够允许它增长一倍。下一次某个操作需要增长字符串时，现有的缓冲区足够存储新的内容，可以避免申请新的缓冲区。这个小技巧带来的好处是随着字符串变得更长，在字符串后面再添 加字符或是字符串的开销近似于一个常量;而其代价则是字符串携带了一些未使用的内存 空间。如果字符串的实现策略是字符串缓冲区增大为原来的两倍，那么在该字符串的存储空间中，有一半都是未使用的。

```c++
int i,j;
i = 3; // i的值是3
j = i; // j的值也是3
i = 5; // i的值现在是5，但是j的值仍然是3

std::string s1, s2;
s1 = "hot"; // s1是"hot"
s2 = s1; // s2是"hot"
s1[0] = 'n'; // s2仍然是"hot"，但s1变为了"not" 
```

> 由于字符串就是值，因此字符串表达式的结果也是值。如果你使用s1 = s2 + s3 + s4;这 条语句连接字符串，那么 s2 + s3 的结果会被保存在一个新分配的临时字符串中。连接 s4 后的结果则会被保存在另一个临时字符串中。这个值将会取代 s1 之前的值。接着，为第一 个临时字符串和 s1 之前的值动态分配的内存将会被释放。这会导致多次调用内存管理器。

```c++
//第一次优化
//原始函数 
std::string remove_ctrl(std::string s) {
    std::string result;
    for (int i=0; i<s.length(); ++i) {
        if(s[i] >= 0x20)
          result = result + s[i];
    } 
    return result;
}


//使用复合赋值操作避免临时字符串 
std::string remove_ctrl_mutating(std::string s) {
    std::string result;
    for (int i=0; i<s.length(); ++i) {
        if(s[i] >= 0x20)
          result += s[i];
    } 
    return result;
}

//通过预留存储空间减少内存的重新分配 
std::string remove_ctrl_mutating(std::string s) {
    std::string result;
    result.reserve(s.length());
    for (int i=0; i<s.length(); ++i) {
        if(s[i] >= 0x20)
          result += s[i];
    } 
    return result;
}

//消除对参数字符串的复制 (可能性能会下降)
std::string remove_ctrl_mutating(std::string const& s) {
    std::string result;
    result.reserve(s.length());
    for (int i=0; i<s.length(); ++i) {
        if(s[i] >= 0x20)
          result += s[i];
    } 
    return result;
}


//使用迭代器消除指针解引 
std::string remove_ctrl_mutating(std::string const& s) {
    std::string result;
    result.reserve(s.length());
    for (auto it = s.begin(), end = s.end(); it != end; ++it) {
        if(*it >= 0x20)
          result += *it;
    } 
    return result;
}

//移除对返回值的复制 
void remove_ctrl_ref_result_it (
            std::string& result,
            std::string const& s)
{
    result.clear();
    result.reserve(s.length());
    for (auto it=s.begin(),end=s.end(); it != end; ++it) {
        if (*it >= 0x20)
          result += *it;
    } 
} 

//在底层编码 
void remove_ctrl_cstrings(char* destp, char const* srcp, size_t size) {
    for (size_t i=0; i<size; ++i) {
        if (srcp[i] >= 0x20)
          *destp++ = srcp[i];
    } 
    *destp = 0;
} 



```



```c++
//第二次优化
//原始函数 
std::string remove_ctrl(std::string s) {
    std::string result;
    for (int i=0; i<s.length(); ++i) {
        if(s[i] >= 0x20)
          result = result + s[i];
    } 
    return result;
}

//使用更好的算 
std::string remove_ctrl_block(std::string s) {
    std::string result;
    for (size_t b=0, i=b, e=s.length(); b < e; b = i+1) {
        for (i=b; i<e; ++i) {
            if (s[i] < 0x20)
              break; 
        } 
        result = result + s.substr(b,i-b);
    }
    return result;
}

//一种更快的算法 
std::string remove_ctrl_block_append(std::string s) {
    std::string result;
    result.reserve(s.length());
    for (size_t b=0,i=b; b < s.length(); b = i+1) {
        for (i=b; i<s.length(); ++i) {
            if (s[i] < 0x20) break;
        } 
        result.append(s, b, i-b);
    }
    return result;
}

//不创建新的字符串，而是修改参数字符串的值作 为结果返回 
std::string remove_ctrl_erase(std::string s) { 
    for (size_t i = 0; i < s.length();) 
      if (s[i] < 0x20)
        s.erase(i,1);
      else ++i;
    return s;
} 

//使用std::stringstream
std::stringstream s;
for (int i=0; i<10; ++i) {
    s.clear();
    s << "The square of " << i << " is " << i*i << std::endl;
    log(s.str());
} 

```

> 字符串函数只适用于对相同类型的字 符串进行比较、赋值或是作为运算对象和参数，因此，程序员必须将一种类型的字符串转 换为另外一种类型。任何时候，涉及复制字符和动态分配内存的转换都是优化性能的机会。



### Chapter 5

> 预计算 
> 可以在程序早期，例如设计时、编译时或是链接时，通过在热点代码前执行计算来将计算从热点部分中移除。
>
>
> 延迟计算 
> 通过在真正需要执行计算时才执行计算，可以将计算从某些代码路径上移除。
>
> 批量处理 
> 每次对多个元素一起进行计算，而不是一次只对一个元素进行计算。
>
> 缓存 
> 通过保存和复用昂贵计算的结果来减少计算量，而不是重复进行计算。
>
> 特化 
> 通过移除未使用的共性来减少计算量。
>
> 提高处理量 
> 通过一次处理一大组数据来减少循环处理的开销。
>
> 提示 
> 通过在代码中加入可能会改善性能的提示来减少计算量。
>
> 优化期待路径 
> 以期待频率从高到低的顺序对输入数据或是运行时发生的事件进行测试。
>
> 
>
> 散列法 
> 计算可变长度字符串等大型数据结构的压缩数值映射(散列值)。在进行比较时，用散 列值代替数据结构可以提高性能。
>
> 双重检查 
> 通过先进行一项开销不大的检查，然后只在必要时才进行另外一项开销昂贵的检查来减少计算量。

### Chapter 6

静态存储期 

> 具有静态存储期的变量被分配在编译器预留的内存空间中。在程序编译时，编译器会为 每个静态变量分配一个固定位置和固定大小的内存空间。静态变量的内存空间在程序的 整个生命周期内都会被一直保留。所有的全局静态变量都会在程序执行进入 main() 前 被构建，在退出 main() 之后被销毁。在函数内声明的静态变量则会在“程序执行第一 次进入函数前”被构建，这表示它可能会和全局静态变量同时被构建，也可能直到第一 次调用该函数时才会被构建。C++ 为全局静态变量指定了构建和销毁的顺序，因此开 发人员可以准确地知道它们的生命周期。但是这些规则太复杂了，实际上在使用存储期 时，这些规则更像是警告而非行为。 
>  我们既可以通过名字访问静态变量，也可以通过指针或是引用来访问该变量。静态变量的名字与指向该变量的指针和引用一样，可能会在这个名字变得有意义之前就出现在了其他静态变量的构造函数中，或是在这个名字被销毁后又出现了其他静态变量的析构函数中。
>
> 为静态变量创建存储空间是没有运行时开销的。不过，我们无法再利用这段存储空 间。因此，静态变量适用于那些在整个程序的生命周期内都会被使用数据。
>
> 在命名空间作用域内定义的变量以及被声明为 static 或是 extern 的变量具有静态 存储期。

#### 线程局部存储期 

> 自 C++11 开始，程序可以声明具有线程局部存储期的变量。在 C++11 之前，有些编译器和框架也以一种非标准的形式提供了类似的机制。 
>
> 线程局部变量在进入线程时被构建，在退出线程时被析构。它们的生命周期与线程的生命周期一样。每个线程都包含一份这类变量的独立的副本。
>
>  访问线程局部变量可能会比访问静态变量开销更高，这取决于操作系统和编译器。在某些系统中，线程局部存储空间是由线程分配的，所以访问线程局部变量的开销比访问全 局变量的开销多一次指令。而在其他系统中，则必须通过线程 ID 索引一张全局表来访 问线程局部变量。尽管这个操作的时间开销是常量时间，但是会发生一次函数调用和一 些计算，导致访问线程局部变量的开销变得更大。
>
> 自 C++11 开始，用 thread_local 存储类型指示符关键字声明的变量具有线程局部存储期。

#### 自动存储期 

> 具有自动存储期的变量被分配在编译器在函数调用栈上预留的内存空间中。在编译时， 编译器会计算出距离栈指针的偏移量，自动变量会以该偏移量为起点，占用一段固定大 小的内存，但是自动变量的绝对地址直到程序执行
>
> 进入变量的作用域内才会确定下来。 
> 在程序执行于大括号括起来的代码块内的这段时间，自动变量是一直存在的。当程序运 行至声明自动变量的位置时，会构建自动变量;当程序离开大括号括起来的代码块时， 自动变量将会被析构。 
>
> 与静态变量一样，我们可以通过名字访问自动变量。但是与静态变量不同的是，该名字只在变量被构建后至被析构前可见。当变量被析构后，指向该变量的指针和引用可能仍然存在，而解引它们会导致未定义的程序行为。
>
> 与静态变量一样，为自动变量分配存储空间不会发生运行时开销。但与静态变量不同的 是，自动变量每次可以占用的总的存储空间是有限的。当递归不收敛或是发生深度函数 嵌套调用导致自动变量占用的存储空间大小超出这个最大值时，会发生栈溢出，导致程 序会突然终止。自动变量适合于那些只在代码块附近被使用的对象。 
>
> 函数的形参变量具有自动存储期。除非使用了特殊的关键字，那些声明在可执行代码块内部的变量也具有自动存储期。

#### 动态存储期

> 具有动态存储期的变量被保存在程序请求的内存中。程序会调用内存管理器，即 C++ 运行时系统函数和代表程序管理内存的数据结构的集合。程序会在 new 表达式(在 13.1.3 节进行详细讲解)中显式地为动态变量请求存储空间并构建动态变量，这可能会 发生在程序中的任何一处地方。稍后，程序在 delete 表达式(在 13.1.4 节进行详细讲 解)中显式地析构动态变量，并将变量所占用的内存返回给内存管理器。当程序不再需 要该变量时，这可能会发生在程序的任何一处地方。 
> 与自动变量类似，但与静态变量不同的是，动态变量的地址是在运行时确定的。不同于静态变量、线程局部变量和自动变量的是，数组的声明语法被扩展了，这样可以 在运行时通过一个(非常量)表达式来指定动态数组变量的最高维度。在 C++ 中，这 是唯一一种在编译时变量所占用的内存大小不固定的情况。 
> 动态变量没有自己的名字。当它被构建后，C++ 内存管理器会返回一个指向动态变量的 指针。程序必须将这个指针赋值给一个变量，这样就可以在最后一个指向该变量的指针 被析构之前，将动态变量返回给内存管理器，否则就会有因不断地创建动态变量而耗尽 内存的危险。如果没有正确地返回动态变量，现代处理器可能会在数分钟内耗尽数吉字 节的内存。 
>
> 不同于静态变量和线程局部变量的是，动态变量的数量和类型可以随着时间改变，而不受到它们所消耗的内存总量的限制。另外，与静态变量和自动变量不同的是，管理动态变量使用的内存时会发生显著的运行时开销。
> new 表达式返回的变量具有动态存储期。





> 全局所有权 
> 具有静态存储期的变量整体上被程序所有。程序会在进入 main() 前构建它们，并在从 main() 返回后销毁它们。 
>
> 词法作用域所有权 
> 具有自动存储期的变量被一段由大括号括起来的代码块构成的词法作用域所拥有。词法 作用域可能是函数体，if、while、for 或者 do 控制语句块，try 或者 catch 子句，抑或 是由大括号括起来的多条语句。这些变量在程序进入词法作用域时会被构建，在程序退 出词法作用域时会被销毁。 
> 最外层的词法作用域，即最先进入和最后退出的词法作用域，是 main() 的函数体。也 就是说，声明在 main() 中的自动变量的生命周期与静态变量相同。 
>
> 成员所有权 
> 类和结构体的成员变量由定义它们的类实例所有。当类的实例被构建时，它们会被类的构造函数构建;当类的实例被销毁时，它们也会随之被销毁。
>
> 动态变量所有权 
> 动态变量没有预定义的所有者。取而代之，new 表达式创建动态变量并返回一个必须 由程序显式管理的指针。动态变量必须在最后一个指向它的指针被销毁之前，通过 delete 表达式返回给内存管理器销毁。因此，动态变量的生命周期是可以完全通过编 程控制的，它是一个强大且危险的工具。如果在最后一个指向它的指针被销毁之前，动 态变量没有通过 delete 表达式被返回给内存管理器，内存管理器将会在程序剩余的运行时间中丢失对变量的跟踪。 
> 动态变量的所有权必须由程序员执行并编写在程序逻辑中。它不受编译器控制，也不由 C++ 定义。动态变量所有权对于性能优化非常重要。具有强定义所有权的程序会比所有 权分散的程序更高效。

> 使用智能指针实现动态变量所有权的自动化 。
> 1. 动态变量所有权的自动化 
> 2. 共享动态变量的所有权的开销更大
> 3. std::auto_ptr与容器类 

#### 减少动态变量的使用

> 静态地创建类实例 
>  MyClass myInstance("hello", 123);
>
> 静态地创建类的成员变量 
> 当类的成员变量也是类时，我们可以在创建类时静态地创建这些成员变量。这样可以节省 为这些成员变量分配内存的开销.
> 使用静态数据结构 
> std::string、std::vector、std::map 和 std::list 是 C++ 程序员几乎每天必用的容器。 只要使用得当，它们的效率还是比较高的。但它们并非是唯一选择。当向容器中添加新 的元素时，std::string 和 std::vector 偶尔会重新分配它们的存储空间。std::map 和 std::list 会为每个新添加的元素分配一个新节点 。
>
> 用std::array替代std::vector
>  在栈上创建大块缓冲区
>  静态地创建链式数据结构 
>  struct cyclenode {
>            char const* name;
>            cyclenode* next;
> } extern cyclenode first; // 前向引用 
> cyclenode fourth = { "4", &first ); 
> cyclenode third = { "3", &fourth }; 
> cyclenode second = { "2", &third }; 
> cyclenode first = { "1", &second }; 
>
> 在数组中创建二叉树 
>
> 用环形缓冲区替代双端队列
>
> 使用std::make_shared替代new表达式 
> std::shared_ptr<MyClass> p = std::make_shared<MyClass>("hello", 123); 
> auto p = std::make_shared<MyClass>("hello", 123); 

#### 预分配动态变量以防止重新分配

```c++
std::string errmsg;
errmsg.reserve(100); // 下面这些字符串连接操作中只会发生一次内存分配 
errmsg += "Error 1234: variable ";
errmsg += varname;
errmsg += " was used before set. Undefined behavior."; 

```

#### 在循环外创建动态变量

```c++
for (auto& filename : namelist) {
         std::string config;
         ReadFileXML(filename, config);
         ProcessXML(config);
} 
// 改进
std::string config;
     for (auto& filename : namelist) {
         config.clear();
         ReadFileXML(filename, config);
         ProcessXML(config);
} 

```

#### 移除无谓的复制

> 所有可以被直接赋值的实体都是 char、 int、float和指针等基本类型，它们都会被保存在一个单独的寄存器中。因此，类似a = b 这样的赋值语句是高效的，只会生成一两个用于获取 b 的值并将其存在 a 中的指令。在 C++ 中，char、int 或是 float 等基本类型的赋值同样高效。
>
> 复制可能会发生于以下任何一种情况下: 
>
> 1. 初始化(调用构造函数)  
> 2. 赋值(调用赋值运算符)  
> 3. 函数参数(每个参数表达式都会被移动构造函数或复制构造函数复制到形参中)  
> 4. 函数返回(调用移动构造函数或复制构造函数，甚至可能会调用两次)  
> 5. 插入一个元素到标准库容器中(会调用移动构造函数或复制构造函数复制元素)  
> 6. 插入一个元素到 vector 中(如果需要重新为 vector 分配内存，那么所有的元素都会通  过移动构造函数或复制构造函数复制到新的 vector 中) 

### Chapter 7

> 循环 
>  循环中的语句开销是语句各自的开销乘以它们被重复执行的次数。热点循环必须由开发人员自己找出来。分析器可以指出包含热点循环的函数，但它不会指出函数中的哪个循环是热点循环;它还可能会因为某个函数被一个或多个循环调用而指出该函数，但它也不会指出具体哪个循环是热点循环。既然分析器无法直接指出热点循环，开发人员就必须以分析器的输出结果作为线索，检查代码并找出热点循环。

> 频繁被调用的函数 
> 函数的开销是函数自身的开销乘以它被执行的次数。分析器可以直接指出热点函数。

> 贯穿整个程序的惯用法 
> 这是一个与 C++ 语句和惯用法有关的总类别。在这个类别中，存在着性能开销更小的 选项。如果在程序中广泛地使用了这些惯用法，那么将它替换为性能开销更小的惯用法 可以提升程序的整体性能。 

> 语句级别的性能优化还有一个问题:优化效果取决于编译器。对于如何为一条特定的 C++ 语句生成代码，每种编译器都会有一个或多个方案。适用于某个编译器的编程惯用法可能 在另外一个编译器上毫无效果，甚至反而会降低性能。当在使用 GCC 时可以改善性能的 技巧可能无法适用于 Visual C++。更关键的是，这意味着当团队升级了编译器版本后，新 的编译器可能会降低他们精心优化后的代码的速度。这是语句级别的优化可能比其他性能 优化手段效果更差的另一个原因

```c++
//未优化的 for 循环 
char s[] = "This string has many space (0x20) chars. ";
...
for (size_t i = 0; i < strlen(s); ++i)
    if (s[i] == ' ')
         s[i] = '*'; 

//缓存了循环结束条件值的 for 循环 
for (size_t i = 0, len = strlen(s); i < len; ++i)
    if (s[i] == ' ')
        s[i] = '*'; 
// 对循环进行递减优化 
for (int i = (int)strlen(s)-1; i >= 0; --i)
    if (s[i] == ' ')
        s[i] = '*'; 

//包含具有循环不变性的纯函数的 rotate() 
void rotate(std::vector<Point>& v, double theta) {
    for (size_t i = 0; i < v.size(); ++i) {
        double x = v[i].x_, y = v[i].y_;
        v[i].x_ = cos(theta)*x - sin(theta)*y;
        v[i].y_ = sin(theta)*x + cos(theta)*y;
    } 
}
//将具有循环不变性的纯函数移动到循环外部后的 rotate_invariant() 
void rotate_invariant(std::vector<Point>& v, double theta) {
    double sin_theta = sin(theta);
    double cos_theta = cos(theta);
    for (size_t i = 0; i < v.size(); ++i) {
        double x = v[i].x_, y = v[i].y_;
        v[i].x_ = cos_theta*x - sin_theta*y;
        v[i].y_ = sin_theta*x + cos_theta*y;
    } 
} 

//将循环放入函数以减少调用开销 
//我们来看一个非常简单的例子。下面这个函数的功能是用点(“.”)替代非打印字符: 
#include <ctype> 
void replace_nonprinting(char& c) {
    if (!isprint(c))
        c = '.'; 
} 

for (unsigned i = 0, e = str.size(); i < e; ++i)
     replace_nonprinting(str[i]);


//库的设计者可以重载 replace_nonprinting() 函数来处理整个字符串: 
void replace_nonprinting(std::string& str) {
    for (unsigned i = 0, e = str.size(); i < e; ++i)
        if (!isprint(str[i]))
            c = '.';
} 

//不要频繁地检测事件 
void main_loop(Event evt) {
    static unsigned counter = 1;
    if ((counter % 350) == 0)
      if (poll_for_exit()) 
        exit_program(); // 不返回 
    ++counter; 
    switch (evt) {
        ...
    } 
} 


```

> 从循环中移除隐含的函数调用 
> 普通的函数调用很容易识别，它们有函数名，在圆括号中有参数表达式列表。C++ 代码还 可能会隐式地调用函数，而没有这种很明显的调用语句。当一个变量是以下类型之一时就 可能会发生这种情况: 
>
> 1. 声明一个类实例(调用构造函数) 
> 2. 初始化一个类实例(调用构造函数) 
> 3. 赋值给一个类实例(调用赋值运算符) 
> 4. 涉及类实例的计算表达式(调用运算符成员函数) 
> 5.  退出作用域(调用在作用域中声明的类实例的析构函数)
> 6.  函数参数(每个参数表达式都会被复制构造到它的形参中) 
> 7. 函数返回一个类的实例(调用复制构造函数，可能是两次) 
> 8. 向标准库容器中插入元素(元素会被移动构造或复制构造) 
> 9. 向矢量中插入元素(如果矢量重新分配了内存，那么所有的元素都需要被移动构造或是 复制构造) 

>   1. 函数调用的基本开销 
>
> 有许多细节问题都会降低 C++ 中函数调用的速度，这些问题也构成了函数调用优化的基础。 
>
> 函数参数 
> 除了计算参数表达式的开销外，复制每个参数的值到栈中也会发生开销。如果只有几个小型的参数，那么可 能可以很高效地将它们传递到寄存器中;但是如果有很多参数，那么至少其中一部分需要通过栈传递。
>
> 成员函数调用(与函数调用)
>
> 每个成员函数都有一个额外的隐藏参数:一个指向 this 类实例的指针，而成员函数正是 通过它被调用的。这个    指针必须被写入到调用栈上的内存中或是保存在寄存器中。 
> 调用和返回 
>  调用和返回对程序的功能没有任何影响。我们可以通过用函数体替代函数调用来移除这些开销。的确，当函数很小且在函数被调用之前已经定义了函数时，许多编译器都会试图内联函数体。如果不能内联函数，调用和返回就会产生开销。
> 调用函数要求执行地址被写入到栈帧中来生成返回地址。
> 函数返回要求执行地址从栈中被读取出来并加载到执行指针中。在调用和返回时，执行 连续地工作于非连续的内存地址上。正如在 2.2.7 节中所讲过的，计算机能够高效地执 行连续指令。不过，当程序执行需要跨越非连续地址时，可能会发生流水线停顿和高速 缓存未命中。 
>
> 2. 虚函数的开销 
>
> 在 C++ 中可以将任何成员函数定义为虚函数。继承类能够通过定义一个具有相同函数签名 的成员函数来重写基类的虚成员函数。这样，不论是在继承类实例上调用虚函数还是在一 个指向基类类型的指针或是引用上调用虚函数，都可以使用新的函数体。程序在解引类实 例时会选择调用哪个函数。因此，程序是在运行时通过类实例的实际类型来确定要调用哪 个重写函数的。 
> 每个带有虚成员函数的实例都有一个无名指针指向一张称为虚函数表(vtable)的表，这 张表指向类中可见的每个虚函数签名所关联的函数体。虚函数表指针通常都是类实例的第 一个字段，这样解引时的开销更小。 
>
>
> 3. 继承中的成员函数调用当一个类继承另一个类时，继承类的成员函数可能需要进行一些额外的工作。 
>
>
> 继承类中定义的虚成员函数
>
> 如果继承关系最顶端的基类没有虚成员函数，那么代码必须要给 this 类实例指针加上一 个偏移量，来得到继承类的虚函数表，接着会遍历虚函数表来获取函数执行地址。这些 代码会包含更多的指令字节，而且这些指令通常都比较慢，因为它们会进行额外的计 算。这种开销在小型嵌入式处理器上非常显著，但是在桌面级处理器上，指令级别的并 发掩盖了大部分这种额外的开销。 
> 多重继承的继承类中定义的成员函数调用
>
> 代码必须向 this 类实例指针中加上一个偏移量来组成指向多重继承类实例的指针。这种 开销在小型嵌入式处理器上非常显著，但是在桌面级处理器上，指令级别的并发掩盖了 大部分这种额外的开销。 
> 多重继承的继承类中定义的虚成员函数调用
>
> 对于继承类中的虚成员函数调用，如果继承关系最顶端的基类没有虚成员函数，那么代 码必须要给 this 类实例指针加上一个偏移量来得到继承类的虚函数表，接着会遍历虚函 数表来获取函数执行地址。代码还必须向 this 类实例指针加上潜在的不同的偏移量来组 成继承类的类实例指针。这种开销在小型嵌入式处理器上非常显著，但是在桌面级处理 器上，指令级别的并发掩盖了大部分这种额外的开销。 
> 虚多重继承 
>  为了组成虚多重继承类的实例的指针，代码必须解引类实例中的表，来确定要得到指向虚多重继承类的实例的指针时需要加在类实例指针上的偏移量。如前所述，当被调用的函数是虚函数时，这里也会产生额外的间接开销。
>
>
> 4. 函数指针的开销 
>
>   
>
> C++ 提供了函数指针，这样当通过函数指针调用函数时，代码可以在运行时选择要执行的 函数体。除了基本的函数调用和返回开销外，这种机制还会产生其他额外的开销。 
>
> 函数指针(指向非成员函数和静态成员函数的指针)
>
> C++ 允许在程序中定义指向函数的指针。程序员可以通过函数指针显式地选择一个具有 特定签名(由参数列表和返回类型组成)的非成员函数。当函数指针被解引后，这个函 数将会在运行时会被调用。通过将一个函数赋值给函数指针，程序可以显式地通过函数 指针选择要调用的函数。 
>  代码必须解引指针来获取函数的执行地址。编译器也不太可能会内联这些函数。
>
> 成员函数指针 
>  成员函数指针声明同时指定了函数签名和解释函数调用的上下文中的类。程序通过将函数赋值给函数指针，显式地选择通过成员函数指针调用哪个函数。
> 成员函数指针有多种表现形式，一个成员函数只能有一种表现形式。它必须足够通用才能够在以上列举的各种复杂的场景下调用任意的成员函数。我们有理由认为一个成员函 数指针会出现最差情况的性能。
>
> 5. 函数调用开销总结 
>
>    
>
> 因此，C 风格的不带参数的 void 函数的调用开销是最小的。如果能够内联它的话，就没有 开销;即使不能内联，开销也仅仅是两次内存读取加上两次程序执行的非局部转移 3。 
>
> 移除函数调用开销的一种有效方式是内联函数。要想内联函数，编译器必须能够在函数调 用点访问函数定义。那些函数体在类定义中的函数会被隐式地声明为内联函数。通过将在 类定义外部定义的函数声明为存储类内联，也可以明确地将它们声明为内联函数。此外， 如果函数定义出现在它们在某个编译单元中第一次被使用之前，那么编译器还可能会自己 选择内联较短的函数。尽管 C++ 标准说 inline 关键字只是对编译器的“提示”，但是实际 上为了编译器自己的销量，它们必须善于内联函数。 
> 当编译器内联一个函数时，那么它还有可能会改善代码，包括移除调用和返回语句。有些 数学计算可能会在编译时完成。如果编译器能够确定当参数为某个特定值时有些分支永远 不会执行，那么编译器会移除这些分支。因此，内联是一种通过在编译时进行计算来移除 多余计算的改善性能的手段。 
>
> 在第一次调用函数之前定义函数(提供函数体)给了编译器优化函数调用的机会。当编译 器编译对某个函数的调用时发现该函数已经被定义了，那么编译器能够自主选择内联这次 函数调用。如果编译器能够同时找到函数体，以及实例化那些发生虚函数调用的类变量、 指针或是引用的代码，那么这也同样适用于虚函数。

```c++ 
//PIMPL 是“Pointer to IMPLementation”的缩写，它是一种用作编译防火墙——一种防止 修改一个头文件会触发许多源文件被重编译的机制——的编程惯用法。
/*
 实现了 PIMPL 后，在编译时，对 foo.h、bar.h 或 baz.h，或者是对 Impl 的实现的改动都会 导致 bigclass.cpp 被重编译，但是 bigclass.h 不会改变，这样就限制了重编译的范围。 
在运行时情况就不同了。PIMPL 给程序带来了延迟。之前 BigClass 中的成员函数可能会 被内联，而现在则会发生一次成员函数调用。而且，现在每次成员函数调用都会调用 Impl 的成员函数。使用了 PIMPL 的工程往往会在很多地方使用它，导致形成了多层嵌套函数 调用。更甚者，这些额外的函数调用层次使得调试变得更加困难
 */

//实现 PIMPL 惯用法之后的 bigclass.h 
class Impl;
     class BigClass {
     public:
         BigClass();
         void f1(int a);
         char f2(float f);
         Impl* impl;
};

// 包含 Impl 的定义的 bigclass.cpp 
# include "foo.h"
# include "bar.h"
# include "baz.h"
# include "bigclass.h"
class Impl {
    void g1(int a);
    void g2(float f);
    Foo foo_;
    Bar bar_;
    Baz baz_;
}; 
void Impl::g1(int a) {
    ...
} 
char Impl::g2(float f) {
    ...
} 
void BigClass::BigClass() {
    impl_ = new Impl;
} 
void BigClass::f1(int a) {
    impl_ -> g1(a);
} 
char BigClass::f2(float f) {
    return impl_ -> g2(f)
} 


```

> 使用静态成员函数取代成员函数 
> 每次对成员函数的调用都有一个额外的隐式参数:指向成员函数被调用的类实例的 this 指 针。通过对 this 指针加上偏移量可以获取类成员数据。虚成员函数必须解引 this 指针来 获得虚函数表指针。 有时，一个成员函数中的处理仅仅使用了它的参数，而不用访问成员数据，也不用调用其 他的虚成员函数。在这种情况下，this 指针没有任何作用。 我们应当将这样的成员函数声明为静态函数。静态成员函数不会计算隐式 this 指针，可以通过普通函数指针，而不是开销更加昂贵的成员函数指针找到它们(请参见 7.2.1 节中的 “函数指针的开销”)。 
>
> 将虚析构函数移至基类中任何有继承类的类的析构函数都应当被声明为虚函数。这是有必要的，这样 delete 表达式将会引用一个指向基类的指针，继承类和基类的析构函数都会被调用。另外一个在继承层次关系顶端的基类中声明虚函数的理由是:确保在基类中有虚函数表指针。继承层次关系中的基类处于一个特殊的位置。如果在这个基类中有虚成员函数声明，那 么虚函数表指针在其他继承类中的偏移量是 0;如果这个基类声明了成员变量且没有声明 任何虚成员函数，但是有些继承类却声明了虚成员函数，那么每个虚成员函数调用都会 在 this 指针上加上一个偏移量来得到虚函数表指针的地址。确保在这个基类中至少有一个 成员函数，可以强制虚函数表指针出现在偏移量为 0 的位置上，这有助于产生更高效的代码。 而析构函数则是最佳候选。如果这个基类有继承类，它就必须是虚函数。在类实例的生命 周期中析构函数只会被调用一次，因此只要不是那些在程序中会被频繁地构造和析构的非 常小的类(而且通常情况下，几乎不会让这些小的类去继承子类)，将其设置为虚函数后 产生的开销是最小的。

>
>
>简化表达式 
>多项式y=ax3 +bx2 +cx+d在C++中可以写为: 
>         y = a*x*x*x + b*x*x + c*x + d; 
>
>这条语句将会执行 6 次乘法运算和 3 次加法运算。
>我们可以根据霍纳法则重复地使用分配 律来重写这条语句: 
>     y = (((a*x + b)*x) + c)*x + d;
>
>这条优化后的语句只会执行 3 次乘法运算和 3 次加法运算 
>
>使用更高效的运算符 
>整数表达式 x*4 可以被重编码为更高效的 x<<2。 
>
>使用整数计算替代浮点型计算 
>浮点型计算的开销是昂贵的。浮点数值内部的表现比较复杂，它带有一个整数型尾数、一 个独立的指数以及两个符号。PC 上实现了浮点型计算单元的硬件可能占到芯片面积的 20%。有些多核处理器会共享一个单独的浮点型计算单元，但是却在每个核心上都有多个 独立的整数计算单元。 
>
>用switch替代if-else if-else 用虚函数替代switch或if 

### Chapter 8

> 给库的优化人员的最好建议是，改动越少越好。不要向类或函数中添加或移除功能，也不 要改变函数签名。这类改动几乎肯定会破坏修改后的库与使用库的程序之间的兼容性。另外一个尽量对库少进行改动的理由是，这样可以缩小需要理解的库的代码的范围。
>
> 接口的稳定性是设计可持续交付的库的核心。 
> 设计优化库与设计其他 C++ 代码是一样的，不过风险更高。 
> 专业优化提示: 测试用例很关键 。
> 在库的设计上，简约是一种美德.。
> 这是简约原则的一个具体示例。由于内存分配非常昂贵，如果可能的话，请在库外部进行 内存分配。例如，应当让库函数通过参数接收内存，然后向其中写值，而不要让库函数分 配并返回内存。 
>
> 多数抽象都不会有超过三层类继承层次 
> 绝大多数抽象的实现都不会超过三层嵌套函数调用 