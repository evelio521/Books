规则:24
	/*理解虚拟函数、多继承、虚基类和RTTI所需的代价*/
	
	//虚函数
	  /*
	   *一个vtbl通常是一个函数指针数组。（一些编译器使用链表来代替数组，但是基本方法是一样的）
	   *在程序中的每个类只要声明了虚函数或继承了虚函数，它就有自己的vtbl，并且类中vtbl的项目
	   *是指向虚函数实现体的指针。
		 *
		 *虚函数所需的第一个代价：你必须为每个包含虚函数的类的virtual talbe留出空间。类的vtbl的
		 *大小与类中声明的虚函数的数量成正比（包括从基类继承的虚函数）。每个类应该只有一个virtual table，
		 *所以virtual table所需的空间不会太大，但是如果你有大量的类或者在每个类中有大量的虚函数，
		 *你会发现vtbl会占用大量的地址空间。
		 *
		 *虚函数所需的第二个代价：在每个包含虚函数的类的对象里，你必须为额外的指针付出代价。
	   *虚函数所需的第三个代价：你实际上放弃了使用内联函数。
	   */
	
	//多继承
	
	  /*
	   *到现在为止我们讨论的东西适用于单继承和多继承，但是多继承的引入，事情就会变得更加复杂
	   *（参见Effective C++条款43）。这里详细论述其细节，但是在多继承里，在对象里为寻找vptr
	   *而进行的偏移量计算会变得更复杂。在单个对象里有多个vptr（每一个基类对应一个）；除了我
	   *们已经讨论过的单独的自己的vtbl以外，还得为基类生成特殊的vtbl。因此增加了每个类和每个
	   *对象中的虚函数额外占用的空间，而且运行时调用所需的代价也增加了一些。
	   */
	//虚基类
		/*多继承经常导致对虚基类的需求。没有虚基类，如果一个派生类有一个以上从基类的继承路径，
		 *基类的数据成员被复制到每一个继承类对象里，继承类与基类间的每条路径都有一个拷贝。程
		 *序员一般不会希望发生这种复制，而把基类定义为虚基类则可以消除这种复制。然而虚基类本
		 *身会引起它们自己的代价，因为虚基类的实现经常使用指向虚基类的指针做为避免复制的手段，
		 *一个或者更多的指针被存储在对象里。
		 */
	//RTTI
	  /*
	   *RTTI能让我们在运行时找到对象和类的有关信息，所以肯定有某个地方存储了这些信息让我们查询。
	   *这些信息被存储在类型为type_info的对象里，你能通过使用typeid操作符访问一个类的type_info对象。
		 *在每个类中仅仅需要一个RTTI的拷贝，但是必须有办法得到任何对象的类型信息。
		 */
		 
		 
		 /*
		 
		 性质           对象大小                     class数据量增加           inlining几率降低
		 虚函数           是                               是                        是
		 多重继承         是															   是                        否
		 虚基类         往往如此                          有时候                      否
		 RTTI             否                               是                        否
		 
		 */