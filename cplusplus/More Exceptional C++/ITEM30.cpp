ITEM30:智能指针成员之一:auto_ptr存在的问题
	//请看下面的类
	// Example 30-1
	//
	class X1
	{
	  // ...
	private:
	  Y* y_;
	};
	//如果X1对象拥有所指向的Y对象，那么X1的设计者为什么不能
	//使用编译器自动的生成析构函数，拷贝构造函数和拷贝赋值函数

  //简单的说，如果X1 的拥有权指向的Y，编译器生成上述函数不会提供正确的功能
  //首先，如果X1拥有Y，X1就得有某个函数，可能是构造函数，来创建Y对象，
  //还得有另外一个函数删除它，可能是X1::X1()
  // Example 30-1(a): Ownership semantics.
	//
	{
	  X1 a; // 分配新的Y对象，并指向他
	
	  // ...
	} // 当a 走出生存空间并被摧毁
	  // 时，他会删除指向的Y
	  
	  //那么，如果使用以成员为单位的缺省拷贝构造函数，就会导致多个X1对象指向
	  //同一个Y对象，将会带来奇怪的后果。如修改一个X1对象会同时修改另一个对象的状态
	  // Example 30-1(b): Sharing, and double delete.
		//
		{
		  X1 a;   // 分配一个新的Y对象并指向他
		
		  X1 b( a ); // b和a 指向同一个Y对象
		
		  // 操作a和b会修改同一个Y对象
		  // the same Y object ...
		
		} // 当b走出生存空间，会删除指向Y的对象...a也会这样做
		  
		//如果使用以成员为单位的缺省拷贝赋值，也会导致多个X1
		//对象指向同一个Y对象，从而，同样状态共享和两次delete问题
		//更有甚者，当一些对象永远没有被删除时，他还会造成资源泄漏
		// Example 30-1(c): Sharing, double delete, plus leak.
		//
		{
		  X1 a;  // 分配一个新Y对象指向它
		
		  X1 b;  // 分配一个新Y对象指向它
		
		  b = a; // b现在和a一样，指向同一个Y对象
		         // 但是没有任何对象指向b创建的Y对象
		
		  // 操作a和b会修改同一个Y对象
		  
		
		} // 当b走出生存空间，会删除指向Y的对象...a也会这样做
		
		  //b分配的Y对象永远没有删除
		
		//2.下面的做法有什么优点和缺点
				// Example 30-2
		//
		class X2
		{
		  // ...
		private:
		  auto_ptr<Y> y_;
		};
		//这会带来一定的好处但没有完全解决问题，自动生成的拷贝构造函数和
		//拷贝赋值函数，还是会做错误的事情，只不过早做不同的错事
		
		//首先，如果X2拥有用户自定义的构造函数，这些构造函数具有异常安全性会更
		//容易，因为构造函数抛出异常，auto_ptr会自动的清楚工作。但是在auto_ptr
		//对象获得Y对象的拥有权之前，X2的设计者还是得分配自己的Y对象并通过一个普通的指针保存
		
		//第二，现在，编译器自动生成的析构函数的确会做正确的事情。当X2对象走出生存空间
		//并被摧毁时，auto_ptr<Y>的析构函数会删除它拥有的Y对象，自动执行清除工作
		//但是有一个限制，如果你依赖自动生成的析构函数，那么在使用了X2 的每一个编译单元中，
		//这个析构函数都得提供定义。这意味着，使用了X2的任何人，Y的定义都必须可见。
		// Example 30-2(a): Y must be defined.
		//
		{
		  X2 a; // 分配新的Y对象指向他
		
		  // ...
		
		} // 当a走出生存空间被摧毁时，删除指向的Y
		  //只有Y存在完整的定义，这才会发生
		  
		//第三，至于自动生成的拷贝构造函数，不在有两次delete问题
		//但是带来了另外一个问题--数据偷窃。被创建的X2对象会偷走被拷贝的X2
		//对象中的Y对象，包括Y的所有信息
		// Example 30-2(b): Grand theft pointer.
		//
		{
		  X2 a; // 分配新的Y对象指向他
		
		  X2 b( a ); // b偷走了a中的Y对象，是a中的y_成员是一个null auto_ptr
		             
		
		  // if a attempts to use its y_ member, it won't
		  // work; if you're lucky, the problem will manifest
		  // as an immediate crash, otherwise it will likely
		  // manifest as a difficult-to-diagnose intermittent
		  // failure
		}
		
		
				
				
									
									
