ITEM18:构造函数失败之二:吸收异常
	//在下面代码中，如果A或B的构造函数抛出异常，C的构造函数有可能吸收这个异常并
	//完全不发出异常吗？
	// Example 18-1
		//
		class C : private A
		{
		  B b_;
		};
		//如果不考虑对象的生命周期，我们可以写出下面的代码
		// Example 18-1(a): Absorbing exceptions?
		//
		C::C()
		try
		  : A ( /*...*/ )   // optional initialization-list
		  , b_( /*...*/ )
		{
		}
		catch( ... )
		{
		  // ?
		}
		//这个try block如何退出？注意以下几点
		//1.这个处理程序不能简单的以return 返回，因为这个不合法
		//2.如果处理程序写上throw，那么无论A::A()或B::B()最初抛出什么异常，他都会重新抛出
		//3.如果处理程序抛出其他某个异常，最终抛出的也就是那个异常，而不是基类或成员子对象的构造函数最初抛出的异常
		//4.如果处理程序没有以抛出异常的方式退出，那么在控制抵达构造函数或析构函数的catch block的末尾时，最初的异常会被自动的重新抛出
		
		//在C++中，只要任何一个基类或成员子对象构造失败。整个对象的构造必然失败。
		

    //Function Try Block的法则
    法则1: 构造函数的function try block处理程序只能用于转化从基类或
    	     成员子对象的构造函数抛出的异常，此外没有其他用途。
    法则2: 析构函数的function try block没有什么实际用处，因为析构函数不应该产生异常
    法则3: 其他所有的function try block都没有用处。
    法则4: 获取未管理资源的操作总是应该放在构造函数体内，绝不要放在初始化列表中。
    法则5: 清除获取未管理资源的操作，总要放在构造函数或析构函数体内局部try block处理程序中，
    	     绝对不要放在构造函数或析构函数的function try block处理程序中。
    法则6: 如果构造函数有异常规范，那么对于基类和成员子对象可能抛出虽有异常，这个异常必须留有余地。
    法则7: 使用Pimpl手法保存类内的可选部分。如果一个成员对象的构造函数可以抛出异常，但是你不需要这个成员也可以照常运作，那么
    	     你可以将这个成员用指针保存，并通过null判断是否得到这个对象。 
    法则8: 尽量以使用获得资源才是初始化的技术类管理资源
    	
   //
   // Example 18-1(c): Auto object
		//
		{
		  X x;//一旦异常发生，无论什么原因，程序都不会在继续进行。
		  g( x ); // do something else
		}

    //为了能够狗在C的构造函数上安全的放上一个空throw规范，A和B必须满足的最小条件？
    //如果你想给一个构造函数加上空throw规范，我们就得承认，所有的基类和成员子对象绝对不会抛出异常。
    //如果基类和成员子对象抛出异常，那么程序会terminate()
